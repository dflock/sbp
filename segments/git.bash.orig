<<<<<<< HEAD
### Defaults
_sbp_git_color_clean_bg=${_sbp_repo_color_clean_bg:-$_sbp_color_green}
_sbp_git_color_clean_fg=${_sbp_repo_color_clean_fg:-$_sbp_color_dgrey}
_sbp_git_color_dirty_bg=${_sbp_repo_color_dirty_bg:-$_sbp_color_pink}
_sbp_git_color_dirty_fg=${_sbp_repo_color_dirty_fg:-$_sbp_color_white}
_sbp_git_max_length=${_sbp_git_max_length:-"20"}
||||||| merged common ancestors
### Defaults
_sbp_git_color_bg=${_sbp_git_color_bg:-$_sbp_color_green}
_sbp_git_color_fg=${_sbp_git_color_fg:-$_sbp_color_dgrey}
_sbp_git_max_length=${_sbp_git_max_length:-"20"}
=======
#! /usr/bin/env bash
>>>>>>> master

<<<<<<< HEAD
function _sbp_generate_git_segment() {
  [[ -n "$(git rev-parse --git-dir 2> /dev/null)" ]] || return 0
  local git_head git_state git_value

  if type __git_ps1 &>/dev/null; then
    git_value=" $(__git_ps1 '%s') "
  else
    git_head=$(sed -e 's,.*/\(.*\),\1,' <(git symbolic-ref HEAD 2>/dev/null || git rev-parse --short HEAD))
    git_state=" $(git status --porcelain | sed -Ee 's/^(.M|M.|.R|R.) .*/\*/' -e 's/^(.A|A.) .*/\+/' -e 's/^(.D|D.) .*/\-/' | grep -oE '^(\*|\+|\?|\-)' | sort -u | tr -d '\n')"
    git_value=" ${git_head}${git_state} "
  fi
||||||| merged common ancestors
function _sbp_generate_git_segment() {
  [[ -n "$(git rev-parse --git-dir 2> /dev/null)" ]] || return 0
  local git_head git_state git_value
  if type __git_ps1 &>/dev/null; then
    git_value=" $(__git_ps1 '%s') "
  else
    git_head=$(sed -e 's,.*/\(.*\),\1,' <(git symbolic-ref HEAD 2>/dev/null || git rev-parse --short HEAD))
    git_state=" $(git status --porcelain | sed -Ee 's/^(.M|M.|.R|R.) .*/\*/' -e 's/^(.A|A.) .*/\+/' -e 's/^(.D|D.) .*/\-/' | grep -oE '^(\*|\+|\?|\-)' | sort -u | tr -d '\n')"
    git_value=" ${git_head}${git_state} "
  fi
=======
[[ -n "$(git rev-parse --git-dir 2> /dev/null)" ]] || exit 0
git_bin=$(type -p git)
git_prompt_helper="$(dirname "$git_bin")$(dirname "$(readlink "$git_bin")")/../etc/bash_completion.d/git-prompt.sh";
>>>>>>> master

<<<<<<< HEAD
  if [[ ! -z "${git_value// }" ]]; then
    regex='\>|\<|\*|\+'
    if [[ $git_value =~ $regex ]]; then
      _sbp_segment_new_color_fg="$_sbp_git_color_dirty_fg"
      _sbp_segment_new_color_bg="$_sbp_git_color_dirty_bg"
    else
      _sbp_segment_new_color_fg="$_sbp_git_color_clean_fg"
      _sbp_segment_new_color_bg="$_sbp_git_color_clean_bg"
    fi
  fi
  git_value=' î‚ '$git_value


  if [[ "${#git_value}" -gt "$_sbp_git_max_length" ]]; then
    _sbp_segment_new_value=$(echo "${git_value}" | sed "s/^\(.\{${_sbp_git_max_length}\}\).* \(.*\)/\1.. \2/" )
  else
    _sbp_segment_new_value=$git_value
||||||| merged common ancestors
  _sbp_segment_new_color_fg="$_sbp_git_color_fg"
  _sbp_segment_new_color_bg="$_sbp_git_color_bg"
  if [[ "${#git_value}" -gt "$_sbp_git_max_length" ]]; then
    _sbp_segment_new_value=$(echo "${git_value}" | sed "s/^\(.\{${_sbp_git_max_length}\}\).* \(.*\)/\1.. \2/" )
  else
    _sbp_segment_new_value=$git_value
=======
if [[ -f "$git_prompt_helper" ]]; then
  source "$git_prompt_helper"
  git_ps1="$(__git_ps1 '%s')"
  git_head=$(cut -d' ' -f1 <<< "$git_ps1")
  if [[ ! "$git_head" == "$git_ps1" ]]; then
    git_state=" $(cut -d' ' -f2- <<< "$git_ps1")"
>>>>>>> master
  fi
else
  git_head=$(sed -e 's,.*/\(.*\),\1,' <(git symbolic-ref HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null))
  [[ -z "$git_head" ]] && exit 0
  git_state=" $(git status --porcelain | sed -Ee 's/^(.M|M.|.R|R.) .*/\*/' -e 's/^(.A|A.) .*/\+/' -e 's/^(.D|D.) .*/\-/' | grep -oE '^(\*|\+|\?|\-)' | sort -u | tr -d '\n')"
fi

if [[ $(( ${#git_head} + ${#git_state} )) -gt "$settings_git_max_length" ]]; then
  git_head_room=$(( settings_git_max_length - ${#git_state} - 2))
  git_head="${git_head:0:$git_head_room}.."
fi
segment_value=" ${git_head}${git_state} "
pretty_print_segment "$settings_git_color_fg" "$settings_git_color_bg" "${segment_value//  / }"
